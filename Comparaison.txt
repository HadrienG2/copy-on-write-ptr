=== VERSION AVEC STD::ONCE_FLAG ===

Creating 20000000 pointers from raw pointers
With a raw shared_ptr, this operation takes 2.10385 s
With cow_ptr, it takes 5.29563 s (2.51711x slower)

Creating AND moving 100000000 pointers
With a raw shared_ptr, this operation takes 13.5634 s
With cow_ptr, it takes 45.7958 s (3.37642x slower)

Copying 40000000 pointers
With a raw shared_ptr, this operation takes 2.292 s
With cow_ptr, it takes 2.71524 s (1.18466x slower)

Reading from 128000000 pointers
With a raw shared_ptr, this operation takes 2.30456 s
With cow_ptr, it takes 2.55358 s (1.10806x slower)

Performing 200000000 pointer copies AND cold writes
With a raw shared_ptr, this operation takes 11.1385 s
With cow_ptr, it takes 108.648 s (9.75427x slower)

Performing 800000000 warm pointer writes
With a raw shared_ptr, this operation takes 14.4702 s
With cow_ptr, it takes 46.8538 s (3.23795x slower)


=== COW_OWNERSHIP_FLAG BASE SUR UN MUTEX ===

Creating 20000000 pointers from raw pointers
With a raw shared_ptr, this operation takes 2.31504 s
With cow_ptr, it takes 2.48566 s (1.0737x slower)        => 2.34x plus rapide (synchronisation inutile supprimée)

Creating AND moving 100000000 pointers
With a raw shared_ptr, this operation takes 14.2057 s
With cow_ptr, it takes 17.8608 s (1.2573x slower)        => 2.69x plus rapide (synchronisation inutile supprimée)

Copying 40000000 pointers
With a raw shared_ptr, this operation takes 2.30163 s
With cow_ptr, it takes 2.75951 s (1.19894x slower)       => Equivalent (pas de synchronisation avant)

Reading from 128000000 pointers
With a raw shared_ptr, this operation takes 2.30476 s
With cow_ptr, it takes 2.55297 s (1.10769x slower)       => Equivalent (pas de synchronisation avant)

Performing 200000000 pointer copies AND cold writes
With a raw shared_ptr, this operation takes 10.9271 s
With cow_ptr, it takes 94.1523 s (8.61639x slower)       => 1.13x plus rapide (synchronisation plus efficace)

Performing 800000000 warm pointer writes
With a raw shared_ptr, this operation takes 14.4376 s
With cow_ptr, it takes 81.401 s (5.63815x slower)        => 0.57x plus rapide (synchronisation MOINS efficace !!!)


=== COW_OWNERSHIP_FLAG BASE SUR DES ATOMICS SEQ_CST ===

Creating 20000000 pointers from raw pointers
With a raw shared_ptr, this operation takes 2.33423 s
With cow_ptr, it takes 2.69419 s (1.15421x slower)

Creating AND moving 100000000 pointers
With a raw shared_ptr, this operation takes 14.0972 s
With cow_ptr, it takes 19.7579 s (1.40155x slower)

Copying 40000000 pointers
With a raw shared_ptr, this operation takes 2.33877 s
With cow_ptr, it takes 3.022 s (1.29213x slower)

Reading from 128000000 pointers
With a raw shared_ptr, this operation takes 2.27835 s
With cow_ptr, it takes 2.56302 s (1.12495x slower)

Performing 200000000 pointer copies AND cold writes
With a raw shared_ptr, this operation takes 10.9241 s
With cow_ptr, it takes 97.6073 s (8.93506x slower)

Performing 800000000 warm pointer writes
With a raw shared_ptr, this operation takes 14.2464 s
With cow_ptr, it takes 76.3853 s (5.36174x slower)


=== COW_OWNERSHIP_FLAG BASE SUR DES ATOMICS AVEC MEMORY_ORDER SOIGNE ===

Creating 20000000 pointers from raw pointers
With a raw shared_ptr, this operation takes 2.28105 s
With cow_ptr, it takes 2.60617 s (1.14253x slower)

Creating AND moving 100000000 pointers
With a raw shared_ptr, this operation takes 13.9653 s
With cow_ptr, it takes 19.6988 s (1.41056x slower)

Copying 40000000 pointers
With a raw shared_ptr, this operation takes 2.31718 s
With cow_ptr, it takes 2.8272 s (1.2201x slower)

Reading from 128000000 pointers
With a raw shared_ptr, this operation takes 2.30769 s
With cow_ptr, it takes 2.55808 s (1.1085x slower)

Performing 200000000 pointer copies AND cold writes
With a raw shared_ptr, this operation takes 10.9183 s
With cow_ptr, it takes 95.8352 s (8.77749x slower)

Performing 800000000 warm pointer writes
With a raw shared_ptr, this operation takes 14.3844 s
With cow_ptr, it takes 70.4739 s (4.89933x slower)


=== CONCLUSION ===

Pour ces scénarios, certes limités, les variables atomiques n'apportent qu'un bénéfice minimal par rapport aux
mutex compte tenu de leur complexité d'utilisation.

Il semble préférable de rester sur un mutex.
