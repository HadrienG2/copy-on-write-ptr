#ifndef COW_PTR_H
#define COW_PTR_H

#include <memory>

#include "cow_ownership_flags/thread_unsafe_flag.hpp"

// The cow_ptr class implements copy-on-write semantics on top of std::shared_ptr
template <typename T,
          typename OwnershipFlag>
class copy_on_write_ptr {
   public:
      // === BASIC CLASS LIFECYCLE ===
   
      // Construct a cow_ptr from a raw pointer, acquire ownership.
      copy_on_write_ptr(T * ptr) :
         m_payload{ptr},
         m_ownership{true}
      { }
      
      // TODO: As a performance optimization, allow direct construction from a shared_ptr, as generated by make_shared
      
      // Move-construct from a copy_on_write_ptr, acquire ownership.
      copy_on_write_ptr(copy_on_write_ptr && cptr) :
         m_payload{cptr.m_payload},
         m_ownership{true}
      { }
      
      // Copy-construct from a copy_on_write_ptr, DO NOT acquire ownership.
      copy_on_write_ptr(const copy_on_write_ptr & cptr) :
         m_payload{cptr.m_payload},
         m_ownership{false}
      { }
      
      // All our data members can take care of themselves on their own.
      ~copy_on_write_ptr() = default;
      
      // Moving a copy_on_write_ptr transfers ownership of the underlying data, so we can keep the default behaviour.
      copy_on_write_ptr & operator=(copy_on_write_ptr && cptr) = default;
      
      // Copying a copy_on_write_ptr DOES NOT transfer ownership of the underlying content, so we need to reset our
      // ownership bit in this scenario.
      copy_on_write_ptr & operator=(const copy_on_write_ptr & cptr) {
         m_ownership.set_ownership(false);
         m_payload = cptr.m_payload;
      }
      
      
      // === DATA ACCESS ===
      
      // Reading from copy-on-write data does not require ownership.
      // CAUTION: Be careful when keeping long-lived references to non-const CoW data, as writes may invalidate them.
      const T & read() const { return *m_payload; }
      
      // Writing to copy-on-write data requires ownership, which must be acquired as needed.
      void write(const T & value) {
         copy_if_not_owner();
         *m_payload = value;
      }
      
      void write(T && value) {
         copy_if_not_owner();
         *m_payload = value;
      }

   private:
      std::shared_ptr<T> m_payload;
      OwnershipFlag m_ownership;
      
      // If we are not the owner of the payload object, make a private copy of it
      void copy_if_not_owner() {
         m_ownership.acquire_ownership_once([this](){
            m_payload = std::make_shared<T>(*m_payload);
         });
      }
};

#endif
