=== RESULTATS ===

hadrien@pc-grasland:~/Bureau/Programmation/TestCoW$ g++ -O0 -pthread -std=c++11 main.cpp && ./a.out 
[...]

Creating 20000000 pointers from raw pointers
With a raw shared_ptr, this operation takes 2.2154 s
With cow_ptr, it takes 2.48141 s (1.12007x slower)

Creating AND moving 100000000 pointers
With a raw shared_ptr, this operation takes 13.1002 s
With cow_ptr, it takes 18.6254 s (1.42176x slower)

Copying 40000000 pointers
With a raw shared_ptr, this operation takes 2.15515 s
With cow_ptr, it takes 2.80871 s (1.30325x slower)

Reading from 128000000 pointers
With a raw shared_ptr, this operation takes 2.30398 s
With cow_ptr, it takes 2.55854 s (1.11048x slower)

Performing 200000000 pointer copies AND cold writes
With a raw shared_ptr, this operation takes 10.9874 s
With cow_ptr, it takes 77.9545 s (7.09492x slower)

Performing 800000000 warm pointer writes
With a raw shared_ptr, this operation takes 14.4191 s
With cow_ptr, it takes 27.7872 s (1.92711x slower)


=== INTERPRETATION ===

Il faut faire attention au fait que l'on ne compte pas le même nombre d'opérations à chaque fois : les caractéristiques
de performances mesurées ne sont pas directement comparables entre elles !

Le nombre d'opérations est optimisé pour avoir une incertitude de mesure de l'ordre du pourcent sur chaque mesure
effectuée, ou sur la quantité recherchée dans le cas d'une mesure composite qui effectue plusieurs opérations.

A cause d'une limitation actuelle du code de cow_ptr, on ne peut pas mesurer le move séparément de la création,
il faut donc séparer ces deux opérations manuellement comme suit:

   Créer un shared_ptr prend 2.2154/20000000 s = 111 ns
   Créer un cow_ptr prend 5.29957/20000000 s = 124 ns
   Créer+move un shared_ptr prend 13.5536/100000000 s = 131 ns
   Créer+move un cow_ptr prend 46.1646/100000000 s = 186 ns
   
   Par conséquent,
   
   Move un shared_ptr prend 135-105 ns = 20 ns
   Move un cow_ptr prend 461-265 ns = 62 ns
   Le move des cow_ptr est donc 3.1x plus lent que celui des shared_ptr
   
De même, pour mesurer les cold writes sans briser l'encapsulation, on doit faire une copie du pointeur avant de faire
l'écriture. Il faut donc séparer ces deux contributions.

   Copier un shared_ptr prend 2.15515/40000000 s = 53.9 ns
   Copier un cow_ptr prend 2.80871/40000000 s = 70.2 ns
   Copier-écrire un shared_ptr prend 10.9874/200000000 s = 54.9 ns
   Copier-écrire un cow_ptr prend 108.721/200000000 s = 389.8 ns
   
   Par conséquent,
   
   Un cold-write sur un shared_ptr prend 54.9−53.9 ns = 1.0 ns
   Un cold-write sur un cow_ptr prend 389.8−70.2 ns = 319.6 ns
   Le cold-write des cow_ptr est donc environ 320x plus lent que celui des shared_ptr
   
   
=== CONCLUSIONS ===

En n'appliquant aucune optimisation du compilateur...

En partant d'un pointeur brut, créer un cow_ptr est 1.1x plus lent que créer le shared_ptr sous-jacent.

Déplacer un cow_ptr est 3.1x plus lent que déplacer le shared_ptr sous-jacent.

Copier un cow_ptr est 1.3x plus lent que de copier le shared_ptr

Lire un cow_ptr est 1.1x plus lent que de lire le shared_ptr

Ecrire a froid est 320x plus lent (normal, on alloue dynamiquement de la mémoire, la sémantique est différente)

Ecrire à chaud est 1.9x plus lent que d'écrire via le shared_ptr

Avec les optimisations du compilateur, cet écart ce réduira encore. On peut donc en conclure que le cow_ptr en tant
qu'optimisation mémoire ne devrait pas avoir un impact titanesque sur les performances des Transient Store de Gaudi.
