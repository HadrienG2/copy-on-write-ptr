=== RESULTATS ===

hadrien@pc-grasland:~/Bureau/Programmation/TestCoW$ g++ -g -O0 -pthread -std=c++11 main.cpp && ./a.out 
[...]

Creating 20000000 pointers from raw pointers
With a raw shared_ptr, this operation takes 2.09611 s
With cow_ptr, it takes 5.30885 s (2.53272x slower)

Creating AND moving 100000000 pointers
With a raw shared_ptr, this operation takes 13.3608 s
With cow_ptr, it takes 45.8155 s (3.42909x slower)

Copying 40000000 pointers
With a raw shared_ptr, this operation takes 2.14467 s
With cow_ptr, it takes 2.73596 s (1.2757x slower)

Reading from 128000000 pointers
With a raw shared_ptr, this operation takes 2.32675 s
With cow_ptr, it takes 2.55403 s (1.09768x slower)

Performing 200000000 pointer copies AND cold writes
With a raw shared_ptr, this operation takes 11.2648 s
With cow_ptr, it takes 108.721 s (9.65141x slower)

Performing 800000000 warm pointer writes
With a raw shared_ptr, this operation takes 14.5954 s
With cow_ptr, it takes 47.0278 s (3.22211x slower)


=== INTERPRETATION ===

Il faut faire attention au fait que l'on ne compte pas le même nombre d'opérations à chaque fois : les caractéristiques
de performances mesurées ne sont pas directement comparables entre elles !

Le nombre d'opérations est optimisé pour avoir une incertitude de mesure de l'ordre du pourcent sur chaque mesure
effectuée, ou sur la quantité recherchée dans le cas d'une mesure composite qui effectue plusieurs opérations.

A cause d'une limitation actuelle du code de cow_ptr, on ne peut pas mesurer le move séparément de la création,
il faut donc séparer ces deux opérations manuellement comme suit:

   Créer un shared_ptr prend 2.10304/20000000 s = 105 ns
   Créer un cow_ptr prend 5.29957/20000000 s = 265 ns
   Créer+move un shared_ptr prend 13.5536/100000000 s = 135 ns
   Créer+move un cow_ptr prend 46.1646/100000000 s = 461 ns
   
   Par conséquent,
   
   Move un shared_ptr prend 135-105 ns = 30 ns
   Move un cow_ptr prend 461-265 ns = 196 ns
   Le move des cow_ptr est donc 6.5x plus lent que celui des shared_ptr
   
De même, pour mesurer les cold writes sans briser l'encapsulation, on doit faire une copie du pointeur avant de faire
l'écriture. Il faut donc séparer ces deux contributions.

   Copier un shared_ptr prend 2.14467/40000000 s = 53.6 ns
   Copier un cow_ptr prend 2.73596/40000000 s = 68.4 ns
   Copier-écrire un shared_ptr prend 11.2648/200000000 s = 56.3 ns
   Copier-écrire un cow_ptr prend 108.721/200000000 s = 543.6 ns
   
   Par conséquent,
   
   Un cold-write sur un shared_ptr prend 56.3−53.6 ns = 2.7 ns
   Un cold-write sur un cow_ptr prend 543.6−68.4 ns = 475.2 ns
   Le cold-write des cow_ptr est donc environ 180x plus lent que celui des shared_ptr
   
   
=== CONCLUSIONS ===

En n'appliquant aucune optimisation du compilateur...

En partant d'un pointeur brut, créer un cow_ptr est 2.5x plus lent que créer le shared_ptr sous-jacent.

Déplacer un cow_ptr est 6.5x plus lent que déplacer le shared_ptr sous-jacent.

Copier un cow_ptr est 1.3x plus lent que de copier le shared_ptr (Plus rapide que move! Mais entraîne un cold-write...)

Lire un cow_ptr est 2.6x plus lent que de lire le shared_ptr

Ecrire a froid est 180x plus lent (normal, on alloue dynamiquement de la mémoire)

Ecrire à chaud est 3.2x plus lent que d'écrire via le shared_ptr
